<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Phòng học VR — hoasinh.gltf</title>

  <!-- A-Frame core -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.1/dist/aframe.min.js"></script>
  <!-- Extras: teleport, physics, super-hands -->
  <script src="https://unpkg.com/aframe-teleport-controls@4.0.1/dist/aframe-teleport-controls.min.js"></script>
  <script src="https://unpkg.com/aframe-super-hands-component@5.0.3/dist/aframe-super-hands.min.js"></script>
  <script src="https://unpkg.com/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <!-- physics system (uses ammo.js) -->
  <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>

  <style>
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #ui { position:fixed; right:12px; top:12px; width:320px; background:rgba(0,0,0,0.55); color:#fff; padding:12px; border-radius:10px; backdrop-filter:blur(4px); }
    #ui h3 { margin:0 0 8px 0; font-size:16px }
    #ui label{display:block; margin:6px 0; font-size:13px}
    #ui input[type=range]{width:100%}
    #status{font-size:12px; opacity:0.9}
    .btn { background:#1e88e5; border:none; padding:8px 10px; color:white; border-radius:6px; cursor:pointer; margin-right:6px }
    .btn.secondary { background:#4caf50 }
  </style>
</head>
<body>

<div id="ui">
  <h3>Phòng học VR — điều khiển</h3>
  <div id="status">Đang chờ tải model...</div>
  <label>Scale: <span id="scaleVal">1.00</span></label>
  <input id="scale" type="range" min="0.05" max="3" step="0.01" value="1">

  <label>Rotate Y (°): <span id="rotVal">0</span></label>
  <input id="rot" type="range" min="-180" max="180" step="1" value="0">

  <div style="margin-top:8px">
    <button id="centerBtn" class="btn">Center model</button>
    <button id="snapBtn" class="btn secondary">Snap to grid</button>
  </div>
  <div style="margin-top:8px">
    <button id="resetBtn" class="btn">Reset camera</button>
    <button id="togglePhys" class="btn secondary">Bật Physics</button>
  </div>
  <p style="margin-top:8px;font-size:12px">Hướng dẫn nhanh: vào chế độ VR (nút gắn sẵn trên trình duyệt/thiết bị). Sử dụng tay cầm/chuột để di chuyển/nhặt vật (grab) và teleport để di chuyển.</p>
</div>

<a-scene background="color: #89c2ff" renderer="antialias: true" physics="gravity: -9.8" vr-mode-ui="enterVRButton: true">
  <a-assets>
    <!-- NOTE: the URL uses the uploaded path. The hosting service will transform this path -> public URL when serving files. -->
    <a-asset-item id="mainModel" src="hoasinh.gltf" crossorigin="anonymous"></a-asset-item></a-asset-item>
  </a-assets>

  <!-- lighting -->
  <a-entity light="type:ambient; intensity:0.6; color:#ffffff"></a-entity>
  <a-entity light="type:directional; intensity:0.8" position="2 4 1"></a-entity>

  <!-- floor / grid -->
  <a-entity id="floor" geometry="primitive: plane; width: 40; height: 40" rotation="-90 0 0" material="shader:flat; color:#ececec; repeat: 40 40" static-body></a-entity>
  <a-grid material="opacity:0.35"></a-grid>

  <!-- camera rig with teleport controls -->
  <a-entity id="rig" position="0 1.6 3">
    <a-entity id="camera" camera look-controls wasd-controls>
      <!-- laser for desktop interaction -->
      <a-entity raycaster="objects: .interactable" line="color: #118ab2; opacity: 0.9" position="0 0 -0.5"></a-entity>
    </a-entity>
    <!-- controllers for VR (hand + teleport) -->
    <a-entity id="leftHand" hand-controls="left" super-hands="colliderEvent: raycaster-intersection" teleport-controls="cameraRig: #rig; teleportOrigin: #camera; button: trigger; collisionEntities: #floor" ></a-entity>
    <a-entity id="rightHand" hand-controls="right" super-hands="colliderEvent: raycaster-intersection" teleport-controls="cameraRig: #rig; teleportOrigin: #camera; button: trigger; collisionEntities: #floor"></a-entity>
  </a-entity>

  <!-- model wrapper: we'll attach the glTF here and control it from JS -->
  <a-entity id="modelRoot" class="interactable" position="0 0 0" rotation="0 0 0">
    <!-- placeholder; model will be cloned from asset and centered/scaled by script -->
  </a-entity>

  <!-- helpers: small table and podium to make scene more realistic -->
  <a-box position="-1 0.45 -1" depth="0.6" height="0.9" width="1.2" material="color:#b47b4e" static-body></a-box>
  <a-box position="1 0.35 -0.5" depth="0.4" height="0.7" width="0.6" material="color:#2f6f4e" static-body></a-box>

  <!-- sky -->
  <a-sky color="#aee1ff"></a-sky>

  <!-- small info panel in world -->
  <a-entity id="infoPanel" position="-2 1.6 -2" rotation="0 25 0">
    <a-plane width="1.6" height="0.7" material="color:#222; opacity:0.7"></a-plane>
    <a-entity position="-0.72 0.18 0.01" text="value: Model: hoasinh.gltf\nNhấn Grab để giữ - Teleport để di chuyển; color:#fff; width:1.4; wrapCount:28"></a-entity>
  </a-entity>

</a-scene>

<script>
// Utility: find the loaded model object and compute bbox to center & scale
AFRAME.registerComponent('model-manager', {
  init: function () {
    const scene = this.el.sceneEl;
    const modelRoot = document.getElementById('modelRoot');
    const asset = document.getElementById('mainModel');
    const status = document.getElementById('status');

    // when asset is loaded, clone & attach
    asset.addEventListener('model-loaded', (e) => {
      status.innerText = 'Model đã tải — đang chuẩn hóa (centering & scaling)...';

      // clone to scene
      const cloned = e.detail.model.clone();
      // ensure cast/receive shadows if available
      cloned.traverse(function (node) {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });

      // attach to wrapper
      while (modelRoot.firstChild) modelRoot.removeChild(modelRoot.firstChild);
      modelRoot.appendChild(cloned);

      // compute bounding box using Three.js
      const box = new THREE.Box3().setFromObject(cloned);
      const size = new THREE.Vector3();
      box.getSize(size);
      const center = new THREE.Vector3();
      box.getCenter(center);

      // desired height (meters) for model to fit on floor nicely
      const desiredHeight = 1.6; // default target height
      let scaleFactor = 1;
      if (size.y > 0) scaleFactor = desiredHeight / size.y;

      // avoid extremely large/small
      scaleFactor = Math.max(0.02, Math.min(3, scaleFactor));

      cloned.scale.setScalar(scaleFactor);

      // after scaling, recompute bbox
      const box2 = new THREE.Box3().setFromObject(cloned);
      const size2 = new THREE.Vector3(); box2.getSize(size2);
      const center2 = new THREE.Vector3(); box2.getCenter(center2);

      // move model so its bottom sits on y=0 and center x/z = 0
      const bottomY = box2.min.y;
      cloned.position.y -= bottomY; // lift so bottom is at y=0
      // shift so center is at origin x/z
      cloned.position.x -= center2.x;
      cloned.position.z -= center2.z;

      // make model interactable via super-hands
      cloned.userData.grabbable = true;
      cloned.traverse(function (node) {
        if (node.isMesh) {
          node.el = node.el || null; // safe
        }
      });

      // expose for UI
      window._vrModel = cloned;
      window._modelScale = scaleFactor;

      // update UI
      document.getElementById('scale').value = parseFloat(scaleFactor.toFixed(2));
      document.getElementById('scaleVal').innerText = parseFloat(scaleFactor.toFixed(2));
      status.innerText = 'Đã sẵn sàng — model được căn giữa và scale ổn định.';
    });

    // fallback error handling
    asset.addEventListener('error', (err) => {
      status.innerText = 'Lỗi tải model. Kiểm tra đường dẫn /mnt/data/hoasinh.gltf hoặc console.';
      console.error('Asset load error', err);
    });
  }
});

// Attach the component to the scene root so it runs
document.querySelector('a-scene').setAttribute('model-manager', '');

// UI bindings
(function(){
  const scaleInput = document.getElementById('scale');
  const rotInput = document.getElementById('rot');
  const scaleVal = document.getElementById('scaleVal');
  const rotVal = document.getElementById('rotVal');
  const centerBtn = document.getElementById('centerBtn');
  const snapBtn = document.getElementById('snapBtn');
  const resetBtn = document.getElementById('resetBtn');
  const togglePhysBtn = document.getElementById('togglePhys');
  const status = document.getElementById('status');

  scaleInput.addEventListener('input', () => {
    const v = parseFloat(scaleInput.value);
    scaleVal.innerText = v.toFixed(2);
    if (window._vrModel) {
      window._vrModel.scale.setScalar(v);
      // after scaling, reposition bottom to floor
      const box = new THREE.Box3().setFromObject(window._vrModel);
      const minY = box.min.y;
      window._vrModel.position.y -= minY;
      window._modelScale = v;
    }
  });

  rotInput.addEventListener('input', () => {
    const deg = parseFloat(rotInput.value);
    rotVal.innerText = deg;
    const root = document.getElementById('modelRoot');
    root.setAttribute('rotation', `0 ${deg} 0`);
  });

  centerBtn.addEventListener('click', () => {
    if (!window._vrModel) return;
    // recenter model to origin horizontally and align bottom to floor
    const box = new THREE.Box3().setFromObject(window._vrModel);
    const center = new THREE.Vector3(); box.getCenter(center);
    window._vrModel.position.x -= center.x;
    window._vrModel.position.z -= center.z;
    const minY = box.min.y; window._vrModel.position.y -= minY;
    status.innerText = 'Đã căn giữa model.';
  });

  snapBtn.addEventListener('click', () => {
    if (!window._vrModel) return;
    // snap to 0.1 grid
    const grid = 0.1;
    window._vrModel.position.x = Math.round(window._vrModel.position.x / grid) * grid;
    window._vrModel.position.y = Math.round(window._vrModel.position.y / grid) * grid;
    window._vrModel.position.z = Math.round(window._vrModel.position.z / grid) * grid;
    status.innerText = 'Snap to grid áp dụng.';
  });

  resetBtn.addEventListener('click', () => {
    const rig = document.getElementById('rig');
    rig.setAttribute('position', '0 1.6 3');
    status.innerText = 'Camera đã reset.';
  });

  togglePhysBtn.addEventListener('click', () => {
    const root = document.getElementById('modelRoot');
    // toggle static-body / dynamic-body for physics interactions
    if (!root.hasAttribute('dynamic-body')) {
      root.setAttribute('dynamic-body', 'mass: 1');
      root.querySelectorAll('*').forEach(n => n.setAttribute && n.setAttribute('dynamic-body', 'mass:0.2'));
      togglePhysBtn.innerText = 'Tắt Physics';
      status.innerText = 'Physics: ON (model có thể rơi/va chạm)';
    } else {
      root.removeAttribute('dynamic-body');
      root.setAttribute('static-body', '');
      root.querySelectorAll('*').forEach(n => (n.removeAttribute && n.removeAttribute('dynamic-body')));
      togglePhysBtn.innerText = 'Bật Physics';
      status.innerText = 'Physics: OFF (model cố định)';
    }
  });

})();

// Make cloned meshes grabbable by super-hands (desktop & VR)
AFRAME.registerComponent('make-grabbable', {
  init: function () {
    const el = this.el;
    el.addEventListener('model-loaded', () => {
      const obj = el.getObject3D('mesh') || el.getObject3D('scene');
      if (!obj) return;
      // mark meshes as interactable so raycaster hits them
      obj.traverse((node) => {
        if (node.isMesh) {
          node.el = el; // not strictly necessary, but safe
          // add class for raycaster
          el.classList.add('interactable');
        }
      });
    });
  }
});

// attach make-grabbable to modelRoot so asset clones inherit interactivity
document.getElementById('modelRoot').setAttribute('make-grabbable', '');

</script>
</body>
</html>
